/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Form Template API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Behavior {
    LoginForm = <any> 'gigya-login-form',
    RegisterForm = <any> 'gigya-register-form',
    CompleteRegistrationForm = <any> 'gigya-complete-registration-form',
    MobileLoginForm = <any> 'gigya-mobile-login-form',
    MobileLoginVerification = <any> 'gigya-mobile-login-verification',
    ForgotPasswordForm = <any> 'gigya-forgot-password-form',
    ForgotPasswordSuccessForm = <any> 'gigya-forgot-password-success-form',
    ResetPasswordForm = <any> 'gigya-reset-password-form',
    ResetPasswordSuccessForm = <any> 'gigya-reset-password-success-form',
    PasswordChangeRequiredForm = <any> 'gigya-password-change-required-form',
    VerificationPendingForm = <any> 'gigya-verification-pending-form',
    TfaRegistrationForm = <any> 'gigya-tfa-registration-form',
    TfaVerificationForm = <any> 'gigya-tfa-verification-form',
    VerificationSentForm = <any> 'gigya-verification-sent-form',
    UpdateProfileForm = <any> 'gigya-update-profile-form',
    TfaEditForm = <any> 'gigya-tfa-edit-form',
    ChangePasswordForm = <any> 'gigya-change-password-form',
    OtpSendCodeForm = <any> 'gigya-otp-send-code-form',
    OtpUpdateForm = <any> 'gigya-otp-update-form',
    TfaForm = <any> 'gigya-tfa-form'
}
/**
 * A single conditional rule for a container.
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {ConditionType}
     * @memberof Condition
     */
    type?: ConditionType;
    /**
     * 
     * @type {ConditionValue}
     * @memberof Condition
     */
    value?: ConditionValue;
}
/**
 * Specific parameters that can modify the behavior of a condition.
 * @export
 * @enum {string}
 */
export enum ConditionParam {
    DataOnRender = <any> 'data-on-render'
}
/**
 * The type of condition that can be applied to a container.
 * @export
 * @enum {string}
 */
export enum ConditionType {
    Condition = <any> 'data-condition',
    Domains = <any> 'data-domains',
    Apikeys = <any> 'data-apikeys',
    Prob = <any> 'data-prob',
    AfterDate = <any> 'data-after-date',
    BeforeDate = <any> 'data-before-date',
    EmptyFields = <any> 'data-empty-fields',
    LoginIdentities = <any> 'data-login-identities'
}
/**
 * The value of a condition, including the rule as a JavaScript expression and optional parameters.
 * @export
 * @interface ConditionValue
 */
export interface ConditionValue {
    /**
     * 
     * @type {string}
     * @memberof ConditionValue
     */
    rule?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConditionValue
     */
    params?: { [key: string]: string; };
}
/**
 * Represents a container that can have multiple conditional visibility rules.
 * @export
 * @interface ContainerTemplate
 */
export interface ContainerTemplate {
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    id?: string;
    /**
     * html tag
     * @type {string}
     * @memberof ContainerTemplate
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    innerHtml?: string;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof ContainerTemplate
     */
    conditions?: Array<Condition>;
}
/**
 * 
 * @export
 * @interface FormTemplate
 */
export interface FormTemplate {
    /**
     * A brief description of the form.
     * @type {string}
     * @memberof FormTemplate
     */
    description?: string;
    /**
     * 
     * @type {Behavior}
     * @memberof FormTemplate
     */
    behavior: Behavior;
    /**
     * 
     * @type {Array<ContainerTemplate>}
     * @memberof FormTemplate
     */
    children: Array<ContainerTemplate>;
    /**
     * Defines which screen to switch in case of successful submission and processing of the form. If not specified, after successful processing of the form, the flow finishes and SAP Customer Data Cloud hides the screen-set (see also Removing the Screen-Set section).
     * @type {string}
     * @memberof FormTemplate
     */
    dataOnSuccessScreen?: string;
    /**
     * A boolean attribute with a default value \"false\". When the value is set to \"true\" and all the required fields in the form have data (from the database), the form is automatically skipped and behaves as if it was successfully submitted and processed. SAP Customer Data Cloud loads the data-on-success-screen if defined, or finishes the flow and hides the screen-set. The data-auto-skip logic also takes into consideration the data-empty-fields settings, so a screen may not be skipped if it has a container that has missing required fields and passes all other defined conditions (so the container is visible).
     * @type {boolean}
     * @memberof FormTemplate
     */
    dataAutoSkip?: boolean;
    /**
     * When specified, this attribute overrides the data-on-success next screen attribute and allows specifying a different next screen when the form is successfully submitted vs. when the screen is auto-skipped. If this attribute is not specified, then the next screen for both cases is determined by the data-on-success attribute.
     * @type {string}
     * @memberof FormTemplate
     */
    dataOnAutoSkipScreen?: string;
    /**
     * Indicates the next screen to display when a screen in a different screen-set was skipped, returning control to the current screen-set.
     * @type {string}
     * @memberof FormTemplate
     */
    dataOnScreensetSkippedScreen?: string;
    /**
     * Indicates the next screen to display when the user is missing a login identity.
     * @type {string}
     * @memberof FormTemplate
     */
    dataOnMissingLoginidScreen?: string;
}
/**
 * 
 * @export
 * @interface Screen
 */
export interface Screen {
    /**
     * A unique identifier for the screen
     * @type {string}
     * @memberof Screen
     */
    id?: string;
    /**
     * 
     * @type {Array<FormTemplate>}
     * @memberof Screen
     */
    forms?: Array<FormTemplate>;
    /**
     * Specifies the next screen to display upon completion of the current screen.
     * @type {string}
     * @memberof Screen
     */
    dataNextScreen?: string;
    /**
     * Specifies the screen to display upon completion of account linking.
     * @type {string}
     * @memberof Screen
     */
    dataOnAccountsLinkedScreen?: string;
    /**
     * Specifies the screen to display when a pending TFA registration is triggered during registration or login.
     * @type {string}
     * @memberof Screen
     */
    dataOnPendingTfaRegistrationScreen?: string;
    /**
     * Specifies the screen to display when a pending registration is triggered during registration or login.
     * @type {string}
     * @memberof Screen
     */
    dataOnPendingRegistrationScreen?: string;
    /**
     * Specifies the screen to display when a conflicting login identifier is detected during social login.
     * @type {string}
     * @memberof Screen
     */
    dataOnExistingLoginIdentifierScreen?: string;
    /**
     * Specifies the screen to display when a pending verification is triggered during registration or login.
     * @type {string}
     * @memberof Screen
     */
    dataOnPendingVerificationScreen?: string;
    /**
     * Specifies the screen to display when a pending TFA is triggered during registration or login.
     * @type {string}
     * @memberof Screen
     */
    dataOnPendingTfaVerificationScreen?: string;
    /**
     * Specifies the screen to display when a  code is sent to the user's email for verification.
     * @type {string}
     * @memberof Screen
     */
    dataOnPendingEmailVerificationCode?: string;
    /**
     * Specifies the screen to display when a password required during password-less registration ( social login, otp ,fido, etc).
     * @type {string}
     * @memberof Screen
     */
    dataOnMissingLoginidScreen?: string;
    /**
     * Specifies the screen to display when a pending password change is triggered.
     * @type {string}
     * @memberof Screen
     */
    dataOnPendingPasswordChangeScreen?: string;
    /**
     * Specifies the screen to display when a pending recent login is triggered.
     * @type {string}
     * @memberof Screen
     */
    dataOnPendingRecentLoginScreen?: string;
}
/**
 * 
 * @export
 * @interface ScreenSet
 */
export interface ScreenSet {
    /**
     * A unique identifier for the screen-set.
     * @type {string}
     * @memberof ScreenSet
     */
    id?: string;
    /**
     * CSS style to apply
     * @type {string}
     * @memberof ScreenSet
     */
    css?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenSet
     */
    links?: Array<string>;
    /**
     * Enables responsive design for the screen-set.
     * @type {boolean}
     * @memberof ScreenSet
     */
    dataResponsive?: boolean;
    /**
     * Defines the width of the screen-set when presented in a dialog.
     * @type {number}
     * @memberof ScreenSet
     */
    dataWidth?: number;
    /**
     * Defines the height of the screen-set when presented in a dialog.
     * @type {number}
     * @memberof ScreenSet
     */
    dataHeight?: number;
    /**
     * Specifies the initial screen to display within the screen-set.
     * @type {string}
     * @memberof ScreenSet
     */
    dataStartScreen?: string;
    /**
     * Style of the dialog when the screen-set is presented in a dialog.
     * @type {string}
     * @memberof ScreenSet
     */
    dataDialogStyle?: ScreenSet.DataDialogStyleEnum;
    /**
     * 
     * @type {Array<Screen>}
     * @memberof ScreenSet
     */
    screens?: Array<Screen>;
}

/**
 * @export
 * @namespace ScreenSet
 */
export namespace ScreenSet {
    /**
     * @export
     * @enum {string}
     */
    export enum DataDialogStyleEnum {
        None = <any> 'none',
        Classic = <any> 'classic',
        Modern = <any> 'modern',
        Legacy = <any> 'legacy'
    }
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set screen set
         * @param {string} screenSet unique name to the screen set
         * @param {ScreenSet} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScreenSet(screenSet: string, body?: ScreenSet, options: any = {}): FetchArgs {
            // verify required parameter 'screenSet' is not null or undefined
            if (screenSet === null || screenSet === undefined) {
                throw new RequiredError('screenSet','Required parameter screenSet was null or undefined when calling postScreenSet.');
            }
            const localVarPath = `/screen-set/{screen-set}`
                .replace(`{${"screen-set"}}`, encodeURIComponent(String(screenSet)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenSet" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set screen set
         * @param {string} screenSet unique name to the screen set
         * @param {ScreenSet} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScreenSet(screenSet: string, body?: ScreenSet, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postScreenSet(screenSet, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Set screen set
         * @param {string} screenSet unique name to the screen set
         * @param {ScreenSet} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScreenSet(screenSet: string, body?: ScreenSet, options?: any) {
            return DefaultApiFp(configuration).postScreenSet(screenSet, body, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Set screen set
     * @param {string} screenSet unique name to the screen set
     * @param {ScreenSet} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postScreenSet(screenSet: string, body?: ScreenSet, options?: any) {
        return DefaultApiFp(this.configuration).postScreenSet(screenSet, body, options)(this.fetch, this.basePath);
    }

}
